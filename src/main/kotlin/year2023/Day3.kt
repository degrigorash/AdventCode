package year2023import tools.readFileimport java.util.regex.Patternfun main() {    Day3().part1()    Day3().part2()}class Day3 {    private val lines = readFile("year2023/day3input")        fun part1() {        val map = listOf(*lines.toTypedArray())        val schemes = mutableListOf<String>()        map.forEachIndexed { index, s ->            val numbers = s.map { it.isDigit() }            var firstIndex = -1            var lastIndex = -1            numbers.forEachIndexed { i, b ->                if (b) {                    if (firstIndex == -1) firstIndex = i                    if (!numbers.getOrElse(i + 1) { false }) lastIndex = i                    if (firstIndex != -1 && lastIndex != -1) {                        var scheme = s.substring(firstIndex, lastIndex + 1)                        s.getOrNull(firstIndex - 1)?.let { scheme += it } // add left                        s.getOrNull(lastIndex + 1)?.let { scheme += it } // add right                        // check top                        map.getOrNull(index - 1)?.let { top ->                            scheme += top.substring(firstIndex, lastIndex + 1)                            top.getOrNull(firstIndex - 1)?.let { scheme += it }                            top.getOrNull(lastIndex + 1)?.let { scheme += it }                        }                        // check bottom                        map.getOrNull(index + 1)?.let { bottom ->                            scheme += bottom.substring(firstIndex, lastIndex + 1)                            bottom.getOrNull(firstIndex - 1)?.let { scheme += it }                            bottom.getOrNull(lastIndex + 1)?.let { scheme += it }                        }                        schemes.add(scheme)                        firstIndex = -1                        lastIndex = -1                    }                }            }        }        println(            schemes.filter { it.any { !it.isDigit() && it != '.' } }                .sumOf { it.filter { it.isDigit() }.toLong() }        )    }    fun part2() {        val map = listOf(*lines.toTypedArray())        val schemes = mutableListOf<String>()        map.forEachIndexed { index, s ->            s.forEachIndexed { i, c ->                if (c == '*') {                    var scheme = ""                    // top                    map.getOrNull(index - 1)?.let { t ->                        var top = t[i].toString()                        // left                        var goLeft = i - 1                        while (goLeft >= 0 && t[goLeft].isDigit()) {                            top = t[goLeft] + top                            goLeft--                        }                        // right                        var goRight = i + 1                        while (t.getOrNull(goRight) != null && t[goRight].isDigit()) {                            top += t[goRight]                            goRight++                        }                        scheme += "$top%"                    }                    // center                    s.let {                        var center = s[i].toString()                        // left                        var goLeft = i - 1                        while (goLeft >= 0 && s[goLeft].isDigit()) {                            center = s[goLeft] + center                            goLeft--                        }                        // right                        var goRight = i + 1                        while (s.getOrNull(goRight) != null && s[goRight].isDigit()) {                            center += s[goRight]                            goRight++                        }                        scheme += "$center%"                    }                    // bottom                    map.getOrNull(index + 1)?.let { t ->                        var bottom = t[i].toString()                        // left                        var goLeft = i - 1                        while (goLeft >= 0 && t[goLeft].isDigit()) {                            bottom = t[goLeft] + bottom                            goLeft--                        }                        // right                        var goRight = i + 1                        while (t.getOrNull(goRight) != null && t[goRight].isDigit()) {                            bottom += t[goRight]                            goRight++                        }                        scheme += bottom                    }                    schemes.add(scheme)                }            }        }        println(            schemes.sumOf {                val numbers = it.split(Pattern.compile("\\D+")).filter { it.isNotEmpty() }                if (numbers.size == 2) {                    numbers[0].toLong() * numbers[1].toLong()                } else {                    0                }            }        )    }}